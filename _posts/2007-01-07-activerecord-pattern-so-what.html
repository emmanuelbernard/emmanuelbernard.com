---
title: 'ActiveRecord pattern, so what?'
author: 'Emmanuel Bernard'
tags: [ grails, java, persistence ]
date: 2007-01-07
---
<p>The <a href='http://en.wikipedia.org/wiki/Active_record'>Active Record</a> pattern has a lot of publicity recently thanks to the Ruby On Rails and <a href='http://grails.codehaus.org/'>Grails </a>wave. A definition could be: an object that encapsulates both data and behavior (ie a database row and it's data access logic).<br/><br/><span style='font-weight: bold;'>A bit of history</span><br/>I was asked recently my thoughts about this pattern. First of all, if someone still remembers EJB 1.0 and 2.x Entity Beans, this was a perfect example of the Active Record Pattern... and a successful failure. Some of the reasons for this failure was the tight link between the data and it's access logic: Serialization issue, data tight to a persistent technology etc etc.<br/><br/><span style='font-weight: bold;'>Statically typed languages</span><br/>To me the ActiveRecord pattern is not well suited for statically typed languages like Java, hence the raise of another pattern : DAO (aka DAL in the .net world). It prevents the hard link between the persistence technology and the actual data representation.<br/><br/><span style='font-weight: bold;'>Dynamic languages</span><br/>Dynamic languages (and to a certain extend AOP) have the nice ability to decorate an object with additional features on the fly, without linking it "the hard way": you can then easily reuse your domain classes out of the persistence context.<br/>Grails uses such a behavior to add CRUD operations transparently to your domain model (with quite complex Querying capabilities).<br/>One still face a problem, what if the application developer needs to add a more complex persistence operation (esp a query), he will end up "hard-coding" the function to the domain object and we're back to the issue faced by statically typed languages... unless you create a DAO object. But then, your persistence operations will be split between your implicit domain model methods and your DAO: another code smell.<br/><br/><span style='font-weight: bold;'>Dynamic DAO</span><br/>As you can see, I'm not keen on the ActiveRecord pattern (out of simple applications), but I really love the simplicity of <a href='http://grails.codehaus.org/GORM'>GORM</a> (the Grails way). The solution is a dynamic DAO. <a href='http://www.jboss.com/products/seam'>JBoss Seam </a>already generates very simple yet powerful DAOs benefiting from Java Generics. If you combine that with a dynamic language, you can have the best of both worlds.<br/><br/><blockquote style='font-family: courier new;'><pre>class UserProcess {<br/>@In UserDao userDao;<br/><br/>void create(String firstname, String lastname) {<br/>  if (userDao.countByFirstnameAndLastname(firstname, lastname) == 0) {<br/>    def user = new User( "Emmanuel", "Bernard" )<br/>    userDao.save user<br/>  }<br/>  else {<br/>    throw new UserAlreadyExistException()<br/>  }<br/>}<br/>}<br/></pre></blockquote><br/><br/>Note that <span style='font-style: italic;'>countByFirstnameAndLastname</span> and <span style='font-style: italic;'>save </span>can be dynamic methods Ã  la GORM.<br/><br/><span style='font-weight: bold;'>Conclusion</span><br/>I'm not a big fan of the ActiveRecord. For static languages, I would use the DAO approach. For dynamic languages, I did not make up my mind but a DAO on steroids seems very promising.</p>
