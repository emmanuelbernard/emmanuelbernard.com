---
title: 'Hibernate Search freshly baked features'
author: 'Emmanuel Bernard'
tags: [ hibernate search ]
date: 2007-06-06
---
<p>I had to release <a href='http://search.hibernate.org/'>Hibernate Search</a> Beta3 early after we discovered a fairly severe bug in Beta2. But I had time to inject some new features. After <a href='http://blog.hibernate.org/cgi-bin/blosxom.cgi/2007/05/31#HSearch-3.0.0.Beta2'>those introduced in Beta2</a>, that a fairly good week :)<br/><br/><span style='font-weight: bold;'>batch size limit on object </span><span style='font-weight: bold;'>indexing</span><span style='font-weight: bold;'/><br/>If you don't pay attention when initially indexing (or reindexing) your data, you may face out of memory exceptions. The old solution was to execute indexing in several smaller transactions, but the code ended up being fairly complex. Here is the new solution:<br/><pre><blockquote>hibernate.search.worker.batch_size=5000<br/><br/>int batchSize=5000;<br/>//scroll will load objects as needed<br/>ScrollableResults results = fullTextSession.createCriteria( Email.class )<br/>    .scroll( ScrollMode.FORWARD_ONLY );<br/>int index = 0;<br/>while( results.next() ) {<br/>    index++;<br/>    fullTextSession.index( results.get(0) ); //index each element<br/>    if (index % batchSize == 0) s.clear(); //clear every batchSize<br/>}<br/></blockquote></pre>wrap that into one transaction and you are good to go.<br/><br/><span style='font-weight: bold;'>Native Lucene</span><br/>The APIs were never officially published (until beta3), but Hibernate Search lets you fall back to native Lucene when needed. All the needed APIs are held by SearchFactory.<br/><br/><pre><blockquote>DirectoryProvider provider = searchFactory.getDirectoryProvider(Order.class);<br/>org.apache.lucene.store.Directory directory = provider.getDirectory();</blockquote></pre>This one is the brute force and gives you access to the Lucene Directory containing Orders. A smarter way, if you intend to execute a search query, is to use the ReaderProvider<br/><pre><blockquote>DirectoryProvider clientProvider = searchFactory.getDirectoryProvider(Client.class);<br/>IndexReader reader = searchFactory.getReaderProvider().openReader(clientProvider);<br/><br/>try {<br/>   //do read-only operations on the reader<br/>}<br/>finally {<br/>   readerProvider.closeReader(reader);<br/>}</blockquote></pre>Smarter because you share the same IndexReaders as Hibernate Search, hence avoid the unnecessary IndexReader opening and warm up.<br/><br/>Finally you can optimize a Lucene Index (roughly a defragmentation)<br/><br/><pre><blockquote>SearchFactory searchFactory = fullTextSession.getSearchFactory();<br/>searchFactory.optimize(Order.class);<br/>//or searchFactory.optimize();</blockquote></pre></p>
