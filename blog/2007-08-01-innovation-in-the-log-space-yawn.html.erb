---
title: 'Innovation in the Log space, yawn...'
author: 'Emmanuel Bernard'
layout: blog-post
tags: [ java ]
---
<p>Steve and I had a discussion yesterday about loggers. I know what you're thinking: hasn't log been a solved problem for years now? Plus it's boring ;)<br/>That's why usually, when a discussion starts on the subject, I tend to carefully not listen. But because it's Steve, and because he has some specific requirement for the next Hibernate Core version, I decided to ignore my own rule.<br/><br/>It turned out to be much more interesting than what I expected. Here are some news for people, like me, that stopped listening to the log crowd when the rule was use log4j and when you can't use commons-logging.<br/><br/>I was pleasantly surprised by <a href='http://slf4j.org/'>slf4j</a>. I know, it's yet another facade and the name is awful. But this project has 2 features that really caught my attention.<br/><br/><span style='font-weight: bold;'>Parameterized log</span><br/>Isn't it very annoying to have to do<br/><br/><pre><blockquote>if ( log.isDebugEnabled() ) {<br/>    log.debug("My dummy " + object1 + " and expensive " + object2  + " concatenation");<br/>}</blockquote></pre><br/>because the object's toString() method are expensive?<br/><br/>slf4j solves that by using parameterized logs<br/><br/><pre><blockquote>log.debug("My dummy {} and expensive {} concatenation", object1, object2);</blockquote></pre><br/>Very elegant and just as efficient as the previous form. Now because slf4j supports JDK 1.3, the API cannot use varargs, which means that for 3 or more parameters you will have to write<br/><br/><pre><blockquote>log.debug("My dummy {} and expensive {} concatenation {}", new Object[] { object1, object2, object 3 });</blockquote></pre><br/><br/>instead of the much more elegant<br/><br/><pre><blockquote>log.debug("My dummy {} and expensive {} concatenation {}", object1, object2, object3);</blockquote></pre><br/><br/>Damn slow movers! I guess most of the time you have 1 or 2 arguments so the pain should be minimal, or you could write you own facade, sigh<br/><br/><span style='font-weight: bold;'>Static binding</span><br/><br/>Once I understood what it meant, I liked it. Basically to switch from one underlying logger to another, you will replace slf4j-mylogger1.jar by slf4j-mylogger2.jar: the slf4j engine is statically bound to an implementation.<br/>OMG! This means I cannot change my logger implementation by hot deploying a config file! Oh, wait a minute, it's useless anyway.<br/>The good side is that classloader hells are behind us.<br/><br/><span style='font-weight: bold;'>The Ultimate Uber Cool solution</span><br/><br/>The ultimate solution is actually what Gavin came up with in Seam. So instead of doing<br/><br/><pre><blockquote>private static final Log log = LogFactory.getLog(CreateOrderAction.class);<br/>       <br/>public Order createOrder(User user, Product product, int quantity) {<br/>    if ( log.isDebugEnabled() ) {<br/>        log.debug("Creating new order for user: " + user.username() +<br/>            " product: " + product.name()<br/>            + " quantity: " + quantity);<br/>    }<br/>    return new Order(user, product, quantity);<br/>}</blockquote></pre><br/>you end up with<br/><br/><pre><blockquote>@Logger private Log log;<br/>       <br/>public Order createOrder(User user, Product product, int quantity) {<br/>    log.debug("Creating new order for user: #{user.username} product: #{product.name} quantity: #0", quantity);<br/>    return new Order(user, product, quantity);<br/>}</blockquote></pre><br/><br/>Notice the parameterized logs, the log injection (yes the framework is smart enough to guess the category, doh!), and the contextual parameters injection.<br/><br/>But such solution is not accessible to library developers until someone decides to push that into the JDK. <br/>OK I'm done for logs for another 5 years time :)</p>
